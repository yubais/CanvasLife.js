// Generated by CoffeeScript 1.6.1
var Canvas, Grid,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Canvas = (function() {

  function Canvas(jqo, defaultStyle) {
    this.jqo = jqo;
    this.width = Number(jqo.attr("width"));
    this.height = Number(jqo.attr("height"));
    this.offset();
    this["default"] = {};
    if (defaultStyle) {
      if (defaultStyle.strokeColor !== void 0) {
        this["default"].strokeColor = defaultStyle.strokeColor;
      }
      if (defaultStyle.fillColor !== void 0) {
        this["default"].fillColor = defaultStyle.fillColor;
      }
    }
  }

  Canvas.prototype.ctx = function() {
    return this.jqo[0].getContext("2d");
  };

  Canvas.prototype.offset = function() {
    var tmp;
    tmp = this.jqo.offset();
    this.left = tmp.left;
    this.top = tmp.top;
    this.right = tmp.left + this.width;
    return this.bottom = tmp.top + this.height;
  };

  Canvas.drawPath = function(ctx, type) {
    if (type === "s") {
      ctx.stroke();
    }
    if (type === "f") {
      ctx.fill();
    }
    if (type === "fs") {
      ctx.fill();
      return ctx.stroke();
    }
  };

  Canvas.prototype.polylinePath = function(ctx, points) {
    var p, _i, _len, _results;
    ctx.beginPath();
    _results = [];
    for (_i = 0, _len = points.length; _i < _len; _i++) {
      p = points[_i];
      _results.push(ctx.lineTo(p[0], p[1]));
    }
    return _results;
  };

  Canvas.prototype.setCtxStyle = function(ctx, style) {
    if (style != null) {
      if (style.strokeWidth === void 0) {
        ctx.lineWidth = this["default"].strokeWidth;
      } else {
        ctx.lineWidth = style.strokeWidth;
      }
      if (style.strokeColor === void 0) {
        ctx.strokeStyle = this["default"].strokeColor;
      } else {
        ctx.strokeStyle = style.strokeColor;
      }
      if (style.fillColor === void 0) {
        return ctx.fillStyle = this["default"].fillColor;
      } else {
        return ctx.fillStyle = style.fillColor;
      }
    }
  };

  Canvas.prototype.line = function(args) {
    var ctx;
    ctx = this.ctx();
    this.setCtxStyle(ctx, args);
    this.polylinePath(ctx, args.points);
    return ctx.stroke();
  };

  Canvas.prototype.polygonal = function(args) {
    var ctx;
    console.log(args);
    ctx = this.ctx();
    this.setCtxStyle(ctx, args);
    this.polylinePath(ctx, args.points);
    ctx.closePath();
    return Canvas.drawPath(ctx, args.type);
  };

  Canvas.prototype.circle = function(args) {
    var ctx;
    ctx = this.ctx();
    this.setCtxStyle(ctx, args);
    ctx.beginPath();
    if (args.center[0] && args.center[1] && args.radius && args.type) {
      ctx.arc(args.center[0], args.center[1], args.radius, 0, Math.PI * 2);
      return Canvas.drawPath(ctx, args.type);
    } else {
      throw new Error("CanvasLife Error: Invalid Parameters");
    }
  };

  Canvas.prototype.allClear = function() {
    var ctx;
    ctx = this.ctx();
    return ctx.clearRect(0, 0, this.width, this.height);
  };

  return Canvas;

})();

Grid = (function(_super) {

  __extends(Grid, _super);

  function Grid(jqo, args) {
    Grid.__super__.constructor.call(this, jqo);
    this.gridColor = "#000";
    this.bgColor = "#080";
    this.cols = args.cols;
    this.rows = args.rows;
    this.xstep = this.width / this.cols;
    this.ystep = this.height / this.rows;
    this.jqo.css("background-color", this.bgColor);
    this.jqo.css("border", "solid 1px " + this.gridColor);
    this.drawGrid('vertical', this.xstep, this.gridColor);
    this.drawGrid('horizontal', this.ystep, this.gridColor);
  }

  Grid.prototype.drawGrid = function(direction, step, color) {
    var ctx, i;
    ctx = this.ctx();
    ctx.beginPath();
    ctx.strokeStyle = color;
    i = 1;
    while (i * step < this.width) {
      if (direction === "horizontal") {
        ctx.moveTo(0, i * step);
        ctx.lineTo(this.width, i * step);
      } else {
        ctx.moveTo(i * step, 0);
        ctx.lineTo(i * step, this.height);
      }
      i++;
    }
    return ctx.stroke();
  };

  return Grid;

})(Canvas);
